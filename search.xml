<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>王道OS看书笔记——内存管理</title>
      <link href="/2025/03/30/OS-learning-2/"/>
      <url>/2025/03/30/OS-learning-2/</url>
      
        <content type="html"><![CDATA[<p>本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</p><h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><h3 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理<strong>的基本原理和要求</strong></h3><ul><li><p><strong>程序的链接和装入（11）</strong></p><ul><li>创建进程首先要将程序和数据装入内存，将用户源程序变成可在内存中执行的程序。</li><li><strong>编译</strong><ul><li>编译程序将用户源代码编译成若干目标模块</li></ul></li><li><strong>链接</strong><ul><li>链接程序将编译后的目标模块以及它们所需的库函数链接在一起，形成完整装入模块</li><li><strong>三种链接方式（链接时间不同）：</strong><ul><li><strong>静态链接</strong><ul><li>运行之前将目标模块和库函数链接，以后不再拆开。</li><li>需要修改相对地址、变换外部调用符号为相对地址<ul><li>GPT: 外部调用符号（external symbol）是指在一个目标文件（object file）中声明或引用的，但定义在另一个目标文件中的符号。</li></ul></li></ul></li><li><strong>装入时动态链接</strong><ul><li>装入内存时，边装入边链接。</li><li>**优点：**便于修改和更新，便于实现对目标模块的共享</li></ul></li><li><strong>运行时动态链接</strong><ul><li>程序执行中需要某目标模块时才链接。</li><li>**优点：**加快程序装入过程，节省内存。</li></ul></li></ul></li></ul></li><li><strong>装入</strong><ul><li>装入程序将装入模块放入内存运行</li><li><strong>三种方式：</strong><ul><li><strong>绝对装入</strong><ul><li>只适用于<strong>单道程序环境</strong></li><li>编译时若知道程序在内存中的位置，则编译产生绝对地址的目标代码</li><li>装入程序按照装入模块的地址将程序和数据装入内存</li></ul></li><li><strong>可重定位装入（静态重定位）</strong><ul><li>编译、链接后的装入模块的起始地址通常从 0 开始</li><li>程序中指令和数据地址都相对于起始地址，此时应该用可重定位装入</li><li><strong>重定位</strong>：装入时对目标程序中的相对地址的修改过程</li><li>作业装入内存时必须分配要求的全部内存，且运行期间不能在内存中移动或继续申请空间</li></ul></li><li><strong>动态运行时装入（动态重定位）</strong><ul><li>地址转换推迟到程序执行时</li><li>装入内存后的所有地址都是相对地址</li><li>需要重定位寄存器存放装入模块的起始位置</li><li><strong>优点：</strong><ul><li>将程序分配到不连续的存储区</li><li>只需要装入部分代码就可以投入运行</li><li>便于程序段共享</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p><strong>逻辑地址和物理地址（23）</strong></p><ul><li><strong>逻辑地址</strong><ul><li>编译后，每个目标模块都从 0 号单元开始编址，称为目标模块的<strong>相对地址（或逻辑地址）</strong></li><li>各模块链接时，链接程序顺序依次按隔各个模块的相对地址构成<strong>统一的</strong>从 0 号单元开始编制的逻辑地址空间（或虚拟地址空间），对于 32 位系统，逻辑地址空间的范围为 0 ~ 2^32 - 1。<ul><li>GPT: 链接程序会将所有这些模块的相对地址整合成一个从 0 号单元开始的统一逻辑地址空间。在这个过程中，链接器会把各个模块的相对地址重新映射为全局的逻辑地址，确保它们在一个连续的逻辑地址空间中排列。</li></ul></li><li>进程运行时，<strong>看到的和使用的都是逻辑地址</strong>。</li><li><strong>用户程序和程序员只需知道逻辑地址</strong>，内存管理的具体机制是透明的（注意透明含义）。</li><li><strong>不同进程可以有相同的逻辑地址</strong>，因为这些地址实际映射到主存的不同位置。</li></ul></li><li><strong>物理地址</strong><ul><li>物理地址空间是内存中物理单元的集合。</li></ul></li><li>OS 通过内存管理部件（MMU）将进程使用的逻辑地址转化为物理地址。</li><li>逻辑地址通过页表映射到物理内存，页表由 OS 维护并被处理器引用。</li></ul></li><li><p><strong>进程的内存映像</strong></p><ul><li>分为**代码段 数据段 PCB 堆 栈 **等等</li><li>代码段和数据段在程序调入内存时就指定大小</li><li>调用 malloc 或 free 这样的函数时，堆会变化</li><li>调用函数或从函数返回，栈会变化</li></ul></li><li><p><strong>内存保护（09）</strong></p><ul><li>内存保护是确保每个进程有单独的内存空间，OS 和用户进程、用户进程之间互不干扰。</li><li><strong>两种方法：</strong><ul><li>在 CPU 设置一堆上下限寄存器，存放用户进程在主存中的上限和下限地址，CPU 访问地址时与寄存器对比确认是否越界。</li><li>采用重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）进行越界检查。重定位寄存器存放进程起始物理地址，界地址寄存器存放进程最大逻辑地址。<ul><li>这两个寄存器的加载必须使用特权指令。内核可以对它们进行修改，用户程序不可以。<br><img src="/2025/03/30/OS-learning-2/1.jpg"></li></ul></li></ul></li></ul></li><li><p><strong>内存共享</strong></p><ul><li><strong>只读</strong>的区域才可以共享。</li></ul></li><li><p><strong>内存分配和回收</strong></p><ul><li>页式存储管理 分段存储管理</li></ul></li></ul><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><ul><li><p><strong>单一连续分配</strong></p><ul><li>内存分为系统区和用户区，系统区仅供 OS 使用，用户区仅有一道用户程序</li><li>简单，无外部碎片</li><li>单用户 单任务</li><li>有内部碎片（分区内部的碎片）</li><li>存储器利用率极低</li></ul></li><li><p><strong>固定分区分配</strong></p><ul><li>用户内存空间划分为若干固定大小的分区，每个分区只装入一道作业。</li><li>有空闲分区时，从外存的后备作业队列选择适当大小的作业装入该分区。</li><li>分区划分大小可以相等，可以不等。</li><li>建立<strong>分区使用表</strong>，便于分配和回收。<br><img src="/2025/03/30/OS-learning-2/2.jpg"></li></ul></li><li><p><strong>动态分区分配（可变分区分配）（10 17 19 24）</strong></p><ul><li><p>进程装入内存时，根据实际需要，动态地分配内存，使大小<strong>正好符合进程需要</strong>。</p></li><li><p>随着时间推移，会产生小内存块**（外部碎片，存在于所有分区的外部）**，内存利用率下降。</p></li><li><p>外部碎片可以通过<strong>紧凑技术</strong>克服，即 OS 不时地对进程进行移动和整理，但需要动态重定位寄存器的支持，且比较费时。</p></li><li><p><strong>内存分配和回收方法</strong></p><ul><li><p>设置一张<strong>空闲分区链（表）</strong>，可以按起始地址排序</p></li><li><p>分配时，检索空闲分区链，找到所需分区：</p><ul><li>若分区大小大于请求大小，则从该分区中<strong>按请求大小分割</strong>一块空间给装入进程（若剩余部分过小，则不需要分割），余下部分仍在空闲分区链中。</li></ul></li><li><p>回收时，根据回收分区的起始地址，从空闲分区链中找到相应插入点，如果回收区和其他空闲分区<strong>相邻，则合并</strong>，最多三块合并。如果没有空闲分区相邻，则不合并。</p></li><li><p><strong>分配算法</strong></p><ul><li><p>作业装入主存时，需要以分配算法从空闲分区链中选出一个分区。</p></li><li><p><strong>顺序分配算法</strong></p><ul><li>依次搜索空闲分区链上的空闲分区，寻找大小合适的分区，有 4 种</li></ul><ol><li><strong>首次适应（First Fit）算法</strong><ul><li>空闲分区按<strong>地址递增次序</strong>排列。</li><li>顺序查找第一个满足大小的分区。</li><li>保留了高地址的大空闲分区，<strong>有利于大作业的装入</strong></li><li>低地址部分出现小碎片，而每次分配查找时都会经过这些分区，<strong>增加开销</strong></li></ul></li><li><strong>邻近适应（Next Fit）算法（循环首次适应算法）</strong><ul><li>其他与首次适应类似，但分配内存时从上次查找结束的位置开始。</li><li>低地址和高地址同等概率被分配</li><li>高地址没有大空闲分区可用</li></ul></li><li><strong>最佳适应（Best Fit）算法</strong><ul><li>空闲分区按<strong>容量递增次序</strong>排列。</li><li>每次分配，顺序查找第一个满足大小的空闲分区，也就是最小的适合的空闲分区</li><li>分配后需要重新排序</li><li>能够更多留下大空闲分区</li><li>每次分配会留下很多小的难以利用的内存块，<strong>产生最多的外部碎片</strong>，性能差。</li></ul></li><li><strong>最坏适应（Worst Fit）算法</strong><ul><li>空闲分区按<strong>容量递减次序</strong>排列。</li><li>每次分配，顺序查找第一个满足大小的空闲分区，也就是最大的空闲分区，分割一部分给作业</li><li>分配后需要重新排序</li><li>划分大空间会导致没有大空间可用，性能差</li></ul></li></ol><ul><li><strong>首次适应算法开销小，性能最好，且分配后不需要重新排序。</strong></li></ul></li><li><p><strong>索引搜索算法</strong></p><ul><li>根据大小对空闲分区分类，每类空闲分区单独设链表</li><li>设置索引表管理这些链表</li><li>分配时，在索引表中查找对应所需空间大小的表项，得到链表头指针，从而获得空闲分区</li><li>大中系统常用</li></ul><ol><li><strong>快速适应算法</strong><ul><li>空闲分区的分类根据<strong>进程常用的空间大小</strong>。</li><li>分配时，首先根据进程长度，在索引表中找到能容纳的最小空闲分区链</li><li>然后从链表中<strong>取出第一块</strong>进行分配</li><li><strong>查找效率高，不产生内部碎片</strong></li><li><strong>回收分区</strong>时，需要有效地<strong>合并分区，算法复杂，开销大</strong>。</li></ul></li><li><strong>伙伴系统（24）</strong><ul><li>规定所有分区的大小为 2 的 k 次幂，分配时寻找能容纳的最小空闲分区链</li><li>如果找到（ 2^i ），则分配；如果找不到，到大小为两倍的空闲分区链中查找</li><li>如果存在，则将其等分，称为<strong>一对伙伴</strong>，一个用于分配，另一个加入大小 2^i 的链表中</li><li>若仍不存在，则继续查找，直到找到为止</li><li>回收时，可能需要对伙伴分区进行合并</li></ul></li><li><strong>哈希算法</strong><ul><li>根据空闲分区链的分布规律，建立哈希函数，构建以空闲分区大小为关键字的哈希表</li><li>每个表项记录一个对应空闲分区链的头指针</li><li>分配时，根据所需大小，通过哈希函数计算得到哈希表中位置，然后得到链表</li></ul></li></ol></li></ul></li></ul></li></ul></li><li><p><strong>对于单一分区分配、固定分区分配和动态分区分配，用户程序在主存中都是连续存放的。</strong></p></li></ul><h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><p>内存空间分为若干固定大小的分区，称为<strong>页框、页帧或物理块</strong></p><p>进程的逻辑地址空间也分为与块<strong>大小相等</strong>的若干区域，称为<strong>页或页面</strong></p><p>分页管理不产生外部碎片。</p><p>进程只有为最后一个不完整的块申请主存块空间时，才会产生内部碎片。</p><p>每个进程平均产生半个块大小的内部碎片</p><ul><li><p><strong>分页存储的基本概念</strong></p><ul><li>进程的逻辑地址空间每个页面有一个编号，称为<strong>页号</strong>，从 0 开始</li><li>内存空间的每个页框也有编号，称为<strong>页框号（物理块号）</strong>，也从 0 开始</li><li>页面大小为 2 的整数次幂，页面太小会使进程页面数过多，页表过长，占用大量内存，也会增加硬件地址转换的开销，降低页面换入&#x2F;换出的效率</li><li>页面过大会使页内碎片增多，降低内存利用率</li><li><strong>分页系统的逻辑地址结构（09 10 13 15 17）</strong><br><img src="/2025/03/30/OS-learning-2/3.jpg"></li><li>系统为每个进程建立一张<strong>页面映射表，简称页表</strong><ul><li>进程每个页面对应一个<strong>页表项</strong></li><li>每个<strong>页表项</strong>由<strong>页号</strong>和<strong>块号</strong>组成，记录了页面在内存中的物理块号</li><li>页表项连续存放，因此<strong>页号可以隐含</strong>，不占空间</li><li>进程执行时，通过查找页表就能找到每页在内存中的物理块号<br><img src="/2025/03/30/OS-learning-2/4.jpg"></li></ul></li></ul></li><li><p><strong>基本地址变换机构（13 21 24）</strong></p><ul><li>地址变换机构的任务是将逻辑地址转换为物理地址。是借助页表实现的。<br><img src="/2025/03/30/OS-learning-2/5.jpg"></li><li>为提高地址变换的速度，在系统中设置一个页表寄存器，存放页表<strong>在内存的起始地址</strong>和<strong>页表长度</strong>。</li><li>进程未执行时，页表起始地址和长度存放在本进程的 PCB 中</li><li>进程被调度执行时，将这两样装入页表寄存器</li><li><strong>页式系统的地址变换过程</strong><ol><li>设页面大小为$L$ 逻辑地址$A$ 物理地址$E$ 页表起始地址 $F$ 页表长度 $M$</li><li>页号 $P&#x3D;A&#x2F;L$ , 页内偏移量 $W&#x3D;A%L$</li><li>判断是否页号是否越界。若页号 $P$ &gt;&#x3D; 页表长度 $M$，则产生越界中断</li><li>在页表中查询页号对应页表项，确定页面存放的物理块号。<ul><li>$P$ 对应的<strong>页表项地址</strong> &#x3D; $F$ + $P$ * 页表项长度</li><li>取出物理块号 $b$</li></ul></li><li>计算物理地址 $E&#x3D;b×L+W$</li></ol></li><li>存在的主要问题<ul><li>每次访存都需要进行逻辑地址到物理地址的转换，地址转换必须足够快</li><li>每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率降低</li></ul></li></ul></li><li><p><strong>具有快表的地址变换机构（09）</strong></p><ul><li>上述地址变换过程，页表在内存中，需要两次访存</li><li>增设一个具有并行查找能力的高速缓冲存储器<strong>快表（TLB）（相联存储器），在 CPU 中</strong><ul><li>快表中存放当前访问的若干<strong>页表项</strong><br><img src="/2025/03/30/OS-learning-2/6.jpg"></li></ul></li><li><strong>地址变换过程</strong><ul><li>CPU 给出逻辑地址，硬件进行地址转换，将页号与快表中所有页号进行比较</li><li>如果有匹配的页号，直接读页框号，得到物理地址</li><li>如果没有，则访问主存中页表，并将页表项存入快表。若快表已满，则按一定算法淘汰一个旧页表项。</li></ul></li></ul></li><li><p><strong>两级页表（10 13 14 15 17 18 19 21）</strong></p><ul><li>页表会占用连续的很大的空间，故引入多级页表</li><li>页表离散分配，为这些页表再建立一张页表，称为<strong>外层页表（页目录）</strong></li><li>以 32 位系统 4KB 页面大小为例<br><img src="/2025/03/30/OS-learning-2/7.jpg"></li><li><strong>两级页表的结构</strong><br><img src="/2025/03/30/OS-learning-2/8.jpg"></li><li><strong>地址变换过程</strong><ul><li>增设一个**外层页表寄存器（页目录基址寄存器），**存放页目录起始地址</li><li>将逻辑地址中页目录号作为页目录索引，找到页表起始地址</li><li>用二级页号作为页表索引，找到页表项</li><li>将页表项中物理块号和页内偏移拼接得到物理地址</li><li>共三次访存</li></ul></li><li>多级页表解决了逻辑地址空间过大时，页表长度大大增加的问题</li><li>一次访盘需要多次访问内存甚至磁盘，大大增加一次访存的时间</li><li>注意第二级页表的大小最大为 1 页（理解：第一级页表也是页表，所指向的区域一定是一页大小）</li></ul></li></ul><h3 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h3><p><strong>分页</strong>通过<strong>硬件机制</strong>实现，对用户透明</p><p><strong>分段</strong>管理考虑了<strong>用户和程序员</strong>，满足编程、信息保护和共享等需要</p><ul><li><p><strong>分段（09）</strong></p><ul><li>分段系统将用户进程的逻辑地址空间分为大小不等的段</li><li>比如用户程序由 主程序段 两个子程序段 栈段 数据段 组成<ul><li>将进程划分为 5 段，<strong>每段从 0 开始编址</strong></li><li><strong>段内地址连续</strong>，段间不要求连续<br><img src="/2025/03/30/OS-learning-2/9.jpg"></li></ul></li><li>段号和段内偏移量由用户显式提供（section .data ？）。高级语言中编译器完成这部分工作。</li></ul></li><li><p><strong>段表（16）</strong></p><ul><li><p><strong>每个进程</strong>都有一张逻辑空间和内存空间映射的<strong>段表</strong>，进程中每个段对应一个段表项</p><table><tr>    <td>段号<br/></td>    <td>段长<br/></td>    <td>本段在主存的起始地址<br/></td></tr></table></li><li><p>执行中的进程可以查找段表，找到每段对应的内存区<br><img src="/2025/03/30/OS-learning-2/10.jpg"></p></li><li><p><strong>地址变换机构</strong></p><ul><li>在系统中设置一个段表寄存器，存放段表起始地址 $F$ 和段表长度 $M$</li><li>从逻辑地址 $A$到物理地址 $E$的转换过程：<ul><li>从逻辑地址中取出前几位段号 $S$，后几位段内偏移量 $W$</li><li>判断段号是否越界。若 $S≥M$，则产生越界中断</li><li>在段表中查询段号对应段表项， $S$对应的**段表项地址 **&#x3D; $F$ + $S$× 段表项长度</li><li>取出段表项中的段长 $C$，若 $W≥C$，则产生越界中断</li><li>取出段表项中该段起始地址 $b$，物理地址 $E&#x3D;b+W$</li></ul></li></ul></li></ul></li><li><p><strong>分页和分段的对比</strong></p><ul><li>页是信息的物理单位，目的是提高内存利用率；段是信息的逻辑单位，目的是更好地满足用户需求</li><li>分页对用户不可见，分段对用户可见</li><li>页的大小固定，段的大小不固定</li><li><strong>分页管理的地址空间是一维</strong>的，而<strong>分段管理</strong>因为每段长度不固定，无法根据一个数得到物理地址，需要显式给出段号和段内偏移，因此是<strong>二维</strong>的。</li></ul></li><li><p><strong>段的共享和保护（19 23）</strong></p><ul><li>分页系统中，可以实现共享，但不方便<ul><li>若被共享的代码占 N 个页框，则每个进程的页表中都要建立 N 个页表项，指向被共享的页框</li></ul></li><li>分段系统中，在<strong>每个进程的段表</strong>中设置一个段表项，指向被共享的物理段</li><li>不能被任何进程修改的代码称为<strong>可重入代码</strong>或者<strong>纯代码</strong><ul><li>这种代码允许多个进程同时访问</li><li>为了防止程序执行时修改共享代码，每个进程中配备局部数据区，将可能改变的部分复制到数据区修改</li></ul></li><li><strong>分段管理的保护</strong><ul><li>存取控制保护（GPT: 权限控制）</li><li>地址越界保护<ul><li>段表寄存器中的段表长度和逻辑地址中段号比较，段号更大则产生越界中断</li><li>段表项中段长和逻辑地址中的段内偏移比较，段内偏移更大则产生越界中断</li></ul></li></ul></li></ul></li></ul><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>进程的地址空间分为若干逻辑段，每段有自己段号，将各段分为若干大小固定的页。</p><p>对内存空间的管理和分页管理一样，分为若干和页面大小一致的存储块，内存分配以存储块为单位。</p><p><img src="/2025/03/30/OS-learning-2/11.jpg"></p><p>段页式系统中的逻辑地址分为<strong>段号 页号和页内偏移量</strong></p><p>系统为<strong>每个进程建立一张段表</strong>，每个段对应一个段表项，每个段表项包括<strong>段号 页表长度 页表起始地址</strong></p><p><strong>每个段有一张页表</strong>，页表项包括页号和块号</p><p>每个进程段表只有一个，页表可能有多个</p><p>系统中有一个<strong>段表寄存器</strong>，指出进程的段表起始地址和段表长度</p><p>段表寄存器和页表寄存器的作用都是在页表或段表中寻址以及判断是否越界。</p><p>地址变换时，首先用段表查到页表起始地址，然后通过页表找到物理块号，形成物理地址。</p><p>该过程需要三次访问主存</p><p>此处也可以使用快表</p><p><img src="/2025/03/30/OS-learning-2/12.jpg"></p><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><ul><li><p><strong>传统存储管理方式的特征</strong></p><ul><li><strong>一次性</strong>。作业必须一次性装入内存才能运行。<ul><li>当作业很大不能全部装入时，无法运行</li><li>大量作业要求运行时，内存不足以容纳所有作业，只能少数先运行，导致并发下降</li></ul></li><li>**驻留性。**作业装入内存后，一直驻留在内存中，任何部分都不会被换出，直到作业运行结束。<ul><li>运行中的进程会因为等待 I&#x2F;O 而被阻塞，可能处于长期等待状态</li></ul></li></ul></li><li><p><strong>局部性原理（12）</strong></p><ul><li><strong>时间局部性</strong><ul><li>程序的某条指令一旦执行，不久后可能再次执行；某数据被访问后，不久后可能再次被访问。</li><li>原因是程序中存在大量循环</li></ul></li><li><strong>空间局部性</strong><ul><li>一旦程序访问了某个存储单元，不久后其附近的存储单元也会被访问</li><li>原因是指令是顺序存放、顺序执行的，数据也一般是向量、数组、表等形式存储的</li></ul></li></ul></li><li><p><strong>虚拟存储器的定义和特征（12）</strong></p><ul><li>基于局部性原理，程序装入时，只需将当前运行所需少数页面或段装入内存，其余暂留外存，便可执行。</li><li><strong>请求调页（请求调段）</strong>：访问的信息不在内存时，OS 将所需信息调入内存，然后继续执行。</li><li><strong>页面置换（段置换）</strong>：内存不够时，OS 将内存中暂时用不到的信息换出到外存</li><li>通过这些操作，系统好像提供了一个比实际物理内存大得多的存储器，称为<strong>虚拟存储器</strong></li></ul></li><li><p><strong>虚拟内存技术的实现</strong></p><ul><li>三种方式：<ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul></li><li>硬件支持：<ul><li>一定容量内存外存</li><li>页表（或段表）机制</li><li>中断机构，当用户访问部分未进入内存时，产生中断</li><li>地址变换机构，从逻辑地址到物理地址</li></ul></li></ul></li></ul><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><ul><li><p><strong>页表机制</strong></p><ul><li>请求页表项相比之前的页表项，增加了四个字段。</li><li><strong>状态位</strong> $P$，标记该页是否已经调入内存，供程序访问时参考</li><li><strong>访问字段</strong> $A$ ，记录本页在一段时间内被访问的次数，或者记录本页最近有多久未被访问</li><li><strong>修改位</strong> $M$，标记该页在调入内存后是否被修改过，以决定换出时是否写回外存</li><li><strong>外存地址</strong>，记录该页在外存的存放地址，通常是物理块号，供调入该页时参考</li></ul></li><li><p><strong>缺页中断机构（11 13 14 20 22 23）</strong></p><ul><li>访问的页面不在内存时，产生<strong>缺页中断</strong>，请求 OS 的缺页中断处理程序处理。</li><li>缺页的进程阻塞，调页完成后再唤醒。</li><li>如果内存中有空闲页框，则为进程分配一个页框，将所缺页面从外存装入页框，修改页表相应表项</li><li>如果没有，则由页面置换算法选一个页面淘汰，若该页在内存期间被修改过，还要写回外存</li><li>缺页中断与一般中断的区别：<ul><li>指令执行期间而非一条指令执行完之后产生和处理中断，属于内部异常</li><li>一条指令执行期间可能产生多次缺页中断</li></ul></li></ul></li><li><p><strong>地址变换机构（09 10 14）</strong></p><ul><li>在基本分页系统地址变换机构的基础上，为了实现虚拟内存，增加了产生和处理缺页中断、从内存中换出一页的功能</li><li><strong>过程：</strong><ul><li>先检索快表<ul><li>若命中，从相应表项中取出物理块号，修改页表中访问位。对于写指令，还要将修改位改为 1。</li><li>若未命中，到页表中查找。<ul><li>若找到，则从相应表项中取出物理块号，并将页表项写入快表。<ul><li>若快表已满，采用某种算法替换。</li></ul></li><li>若未找到，则进行缺页中断处理，请求系统将该页从外存换入内存，OS 更新页表和快表，得到物理块号</li></ul></li></ul></li><li>利用得到的物理块号和页内地址拼接得到物理地址<br><img src="/2025/03/30/OS-learning-2/13.png"></li></ul></li></ul></li></ul><h3 id="页框分配"><a href="#页框分配" class="headerlink" title="页框分配"></a>页框分配</h3><ul><li><p><strong>驻留集大小</strong></p><ul><li>不需要将进程的所有页都读入主存，需要 OS 决定分配几个页框</li><li>分配的页框的集合就是这个进程的<strong>驻留集</strong></li><li>驻留集越小，驻留在内存中进程越多，可以提高并发度，但缺页率提高，CPU 耗费大量时间处理缺页</li><li>驻留集过大，对于缺页率改善不多，浪费内存，大幅降低并发度</li></ul></li><li><p><strong>内存分配策略（15）</strong></p><ul><li>请求分页系统中 有固定和可变分配策略</li><li>置换时有全局和局部置换</li><li><strong>固定分配局部置换</strong><ul><li>固定分配：分配固定数目物理块，进程运行期间不变</li><li>局部置换是指如果发生缺页，只能从分配给该进程在内存中的页面选一页换出，再调入一页，保证分配的内存空间不变</li><li>难以确定分配的数目，过少会频繁缺页，过多会降低 CPU 等利用率</li></ul></li><li><strong>可变分配全局置换</strong><ul><li>先分配一定数目物理块，可增加&#x2F;减少</li><li>全局置换：若发生缺页，则从<strong>空闲物理块队列</strong>中取出一块分配给该进程，并将所缺页调入</li><li>盲目给进程增加物理块，会导致并发能力下降</li></ul></li><li><strong>可变分配局部置换</strong><ul><li>分配一定数目物理块，缺页时只从<strong>该进程在内存中的页面</strong>换出，不影响其他进程</li><li>如果频繁缺页，系统再分配若干物理块，直到缺页率适当</li><li>若缺页率特别低，则减少分配</li></ul></li></ul></li><li><p><strong>物理块调入算法</strong></p><ul><li>固定分配策略的空闲物理块分配算法<ul><li>平均分配</li><li>按进程大小比例</li><li>按进程优先级</li></ul></li></ul></li><li><p><strong>调入页面时机</strong></p><ul><li>预调页策略（运行前）<ul><li>预测不久后可能被访问的页面，预先调入</li><li>预测成功率不高</li><li>主要用于进程首次调入</li></ul></li><li>请求调页策略（运行后）<ul><li>进程需要的页面不在内存，提出请求，系统调入。</li></ul></li></ul></li><li><p><strong>从何处调入页面</strong></p><ul><li>请求分页系统的外存分为<ul><li>用于存放文件的文件区<ul><li>离散分配方式</li></ul></li><li>存放对换页面的对换区（交换区）<ul><li>连续分配方式，I&#x2F;O 速度更快</li></ul></li></ul></li><li>三种情况：<ul><li>系统有足够对换区空间<ul><li>全部从对换区调页，提高速度。</li><li>进程运行前需要将有关文件从文件区复制到对换区</li></ul></li><li>系统没有足够对换区空间<ul><li>不会被修改的文件从文件区调入</li><li>可能被修改的部分 换出时必须放在对换区，需要时从对换区调入（因为读比写快）</li></ul></li><li>UNIX 方式<ul><li>进程有关文件都在文件区，因此未运行过的页面都应从文件区调入</li><li>曾经运行过但被换出的页面，因为放在对换区，下次调入时应该从对换区调入</li><li>进程请求的共享页面如果被其他进程调入内存，不再需要从对换区调入</li></ul></li></ul></li></ul></li><li><p><strong>如何调入</strong></p><ul><li>进程访问页面不在内存中（存在位&#x3D;0），发出缺页中断，转入缺页中断处理</li><li>查表得到该页物理块<ul><li>内存未满，启动磁盘 I&#x2F;O，将所缺页调入内存，修改页表</li><li>内存已满，先按某种置换算法选出一页准备换出<ul><li>若该页未被修改（修改位&#x3D;0），则不需要写回</li><li>若修改位&#x3D;1，需要写回，然后将所缺页调入内存，修改页表</li></ul></li></ul></li></ul></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul><li><p><strong>最佳（OPT）置换算法</strong></p><ul><li>淘汰以后永不使用或者最长时间内不再被访问的页面</li><li>无法实现</li></ul></li><li><p><strong>先进先出（FIFO）置换算法（10 14）</strong></p><ul><li>淘汰最早进入内存的页面</li><li>没有利用局部性原理 性能较差</li><li>可能导致 <strong>Belady 异常</strong><ul><li>为进程分配的物理块增多，缺页次数不减反增的现象</li><li>GPT: 原因：这种算法的简单性可能导致一些正在频繁使用的页面被替换出内存，导致缺页率增加。</li><li>只有 FIFO 算法会导致 Belady 异常，LRU 和 OPT 算法不会出现</li></ul></li></ul></li><li><p><strong>最近最久未使用（Least Recently Used, LRU）置换算法（09 15 19）</strong></p><ul><li>淘汰最近最久未使用的页面</li><li>为每个页面设置一个访问字段，记录页面自上次访问以来经历的时间<ul><li>淘汰时选择值最大的页面</li></ul></li><li><strong>性能较好</strong>，接近 OPT，但<strong>开销大</strong></li><li>需要寄存器和栈的硬件支持</li><li>LRU 是堆栈类算法，可以证明堆栈类算法不会出现 Belady 异常</li></ul></li><li><p><strong>时钟（CLOCK）算法（10 12 16 18 21）</strong></p><ul><li><strong>简单的 CLOCK 置换算法</strong><ul><li>每个页面设置一个<strong>访问位</strong><ul><li>页面首次被装入或被访问时，访问位修改为 1</li></ul></li><li>算法将内存中的页面链接成一个循环队列，并有一个替换指针与之相关联<ul><li>指针顺序移动 初始指向第一个页</li><li>指针只在选择要替换的页面的时候移动，如果没有发生缺页不会移动</li><li>选择淘汰一页的时候，检查页面的<strong>访问位</strong><ul><li>若为 1，改为 0</li><li>若为 0，淘汰</li></ul></li><li>当某一页被替换时，该指针指向<strong>被替换页面的下一页</strong></li></ul></li><li>也称最近未用（NRU）算法</li></ul></li><li><strong>改进 CLOCK 置换算法</strong><ul><li>将页面换出的时候，若已被修改，需要写回磁盘，替换代价大</li><li>与上一种相比，添加了一个修改位</li><li>访问位 A 修改位 M<ul><li>A &#x3D; 0, M &#x3D; 0 最佳淘汰页</li><li>A &#x3D; 0, M &#x3D; 1 次佳淘汰页</li><li>A &#x3D; 1, M &#x3D; 0 或 1 可能再次被访问</li></ul></li><li><strong>算法执行过程</strong><ul><li>与简单 CLOCK 相似</li><li>从指针当前位置开始，扫描循环队列，寻找 A &#x3D; 0 M &#x3D; 0 的 1 类页面，将第一个 1 类页面作为淘汰页。<ul><li>第一次扫描期间不改变访问位 A</li></ul></li><li>若第一步失败，则进行第二轮扫描，寻找 A &#x3D; 0 M &#x3D; 1 的 2 类页面，将第一个 2 类页面作为淘汰页。<ul><li>第二次扫描将所有扫描过的页面访问位改为 0</li></ul></li><li>若第二步失败，则指针返回开始位置，将所有页面访问位设为 0。</li><li>重复第一步，若有必要则重复第二步，一定能找到淘汰页。</li></ul></li><li>比简单 CLOCK 减少磁盘 I&#x2F;O 次数，但实现算法本身开销可能增加</li></ul></li></ul></li></ul><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><ul><li><p>内存映射文件是 OS 提供的一个<strong>系统调用</strong></p></li><li><p>与虚拟内存相似，在磁盘文件和进程的虚拟地址空间之间建立映射</p></li><li><p>将一个文件映射到其虚拟地址空间的某个区域，之后用访问内存的方式读写文件</p><ul><li>将文件作为内存中一个大字符数组访问，比文件 I&#x2F;O 更便利</li></ul></li><li><p>磁盘文件的读写由 OS 完成，对进程透明</p></li><li><p>退出或者关闭文件映射的时候，改动才写回磁盘</p></li><li><p>很多时候，<strong>共享内存</strong>是通过映射相同文件到通信进程的虚拟地址空间实现的</p></li><li><p>一个进程在共享内存上进行了写操作，另一个进程能立刻读到结果</p></li></ul><p><img src="/2025/03/30/OS-learning-2/14.png"></p><h3 id="虚拟存储器性能影响因素（20-22）"><a href="#虚拟存储器性能影响因素（20-22）" class="headerlink" title="虚拟存储器性能影响因素（20 22）"></a>虚拟存储器性能影响因素（20 22）</h3><ul><li>缺页率是影响虚拟存储器性能的主要因素<ul><li>缺页率又受到页面大小 分配的物理块数 页面置换算法 程序编制方法的影响</li><li>页面较大，缺页率较低；页面较小，减少内存碎片，提高内存利用率</li><li>分配给进程物理块越多，缺页率越低，但超过某个数目时，对缺页率降低不明显</li><li>LRU CLOCK 等置换算法缺页率低</li><li>编写程序的局部化程度越高，缺页率越低<ul><li>若存储按行，访问时就要尽量采用相同方式</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>王道OS看书笔记——进程与线程</title>
      <link href="/2025/03/30/OS-learning-1/"/>
      <url>/2025/03/30/OS-learning-1/</url>
      
        <content type="html"><![CDATA[<p>本文为我考研期间看王道书时写的飞书笔记，根据各知识点的逻辑关系进行整理，添加了一点自己的理解，内容不如王道书全。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程 最基本的两个特性 <strong>并发性和共享性</strong></p><p>引入进程的目的：更好地使多道程序并发，提高资源利用率和系统吞吐量。</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。（<strong>系统资源</strong>指 CPU 存储器 等服务于某个进程的时间）</p><ul><li>专门的数据结构 **进程控制块 PCB，**是进程实体的一部分，<strong>是进程存在的唯一标志。</strong><ul><li>PCB 常用的组织方式有<strong>链接方式和索引方式</strong>。<ul><li>链接方式将<strong>同一状态的 PCB 链接成一个队列</strong>，不同状态对应不同队列。 也可以将处于阻塞态的进程的 PCB，根据其<strong>阻塞原因</strong>的不同，排成多个阻塞队列。</li><li>索引方式将<strong>同一状态的进程组织在一个索引表</strong>中，索引表的表项指向相应的 PCB。</li></ul></li></ul></li></ul><p>多个进程可以运行同一个程序。</p><h3 id="进程的状态和转换（14-15-18-23）"><a href="#进程的状态和转换（14-15-18-23）" class="headerlink" title="进程的状态和转换（14 15 18 23）"></a>进程的状态和转换（14 15 18 23）</h3><ol><li><p><strong>运行态</strong>：进程在 CPU 上运行。<strong>单 CPU</strong> 中，每个时刻只有一个进程在运行态。</p></li><li><p><strong>就绪态：<strong>进程获得除了 CPU 以外的一切资源，一旦得到 CPU 便可立即运行。处于就绪态的进程通常排一个队列，   称为</strong>就绪队列</strong>。</p></li><li><p><strong>阻塞态：又称等待态</strong>。进程正在等待某个事件而暂停运行，如<strong>等待某资源可用</strong>**（不包括 CPU）**<strong>或等 I&#x2F;O 完成</strong>。即使 CPU 空闲，也不能运行。处于阻塞态的进程会排一个队列，或根据阻塞原因不同排多个队列。</p></li><li><p>**创建态：**正在被创建，尚未到就绪态。比如创建过程中资源没有得到满足的情况（如内存不足）。</p><ol><li>创建进程的步骤：<ol><li>申请空白 PCB，填写信息</li><li>分配资源</li><li>转入就绪态，插入就绪队列</li></ol></li></ol></li><li><p>**终止态：**进程正在消失，可能是正常结束或者是其他原因。进程需要结束时，系统先将其设置为终止态，然后释放资源、回收等。</p></li></ol><p><strong>注意区分就绪态和阻塞态</strong>。就绪态的进程仅缺少 CPU，阻塞态的进程需要其他资源或者等待某个事件。</p><ul><li><strong>三种基本状态的转换：</strong><ul><li>**就绪态 → 运行态：**处于就绪态的进程被调度后，<strong>获得 CPU 资源</strong>（被分派 CPU 时间片），从而状态转换。</li><li><strong>运行态 → 就绪态：<strong>处于运行态的进程时间片用完后</strong>让出 CPU。<strong>在可剥夺的操作系统中，有</strong>更高优先级的进程就绪</strong>的时候，调度程序将正在执行的进程转为就绪态，让更高优先级的进程执行。</li><li><strong>运行态 → 阻塞态</strong>：进程<strong>请求某一资源（如外设）的使用和分配</strong>，或者<strong>等待某事件发生（如 I&#x2F;O 操作的完成）</strong>，从运行态转为阻塞态。</li><li><strong>阻塞态 → 就绪态：进程等待的事件到来的时候（如 I&#x2F;O 完成或中断结束）</strong>，<strong>中断处理程序</strong>必须将相应进程的状态由阻塞态转为就绪态。</li></ul></li></ul><p>一个进程由运行态到阻塞态是主动的行为，而从阻塞态转为就绪态是被动的行为，需要其他进程协助。</p><p>就绪态和运行态之间是相互的，其他是单向。</p><p><img src="/2025/03/30/OS-learning-1/1.png"></p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>一般将进程控制用的程序段称为原语，执行期间不允许中断。</p><ul><li><p><strong>进程的创建</strong></p><ul><li>允许一个进程创建另一个进程，创建者为父进程，被创建者为子进程。<strong>子进程可以继承父进程的资源，子进程被撤销时，资源应还给父进程。撤销父进程时通常同时撤销所有子进程。（20）</strong></li><li><strong>导致进程创建的操作：（10）</strong><ul><li>终端用户登录系统</li><li>作业调度</li><li>系统提供服务</li><li>用户程序的应用请求</li><li>…</li></ul></li><li><strong>创建新进程的操作：（21）</strong><ol><li><strong>分配一个唯一的进程标识号，申请一个空白 PCB</strong>。若 PCB 申请失败则创建失败。</li><li><strong>分配运行所需资源</strong>，如内存、文件、I&#x2F;O 设备、CPU 时间等（在 PCB 中体现）。资源的来源为操作系统或父进程。若资源不足，则进程为<strong>创建态</strong>，等待资源，<strong>并不会失败</strong>。</li><li><strong>初始化 PCB</strong>，包括标志信息、CPU 状态信息、CPU 控制信息、进程优先级等。</li><li>若就绪队列能够接纳新进程，则进入就绪队列等待调度。</li></ol></li></ul></li><li><p><strong>进程的终止</strong></p><ul><li><strong>引起终止的事件</strong><ul><li>正常结束</li><li>异常结束，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I&#x2F;O 故障等</li><li>外界干预，包括操作员、操作系统干预、父进程请求、父进程终止。</li></ul></li><li><strong>终止进程时的操作（24）</strong><ol><li>根据标识符检索出 PCB，读取进程状态。</li><li>若处于运行态，立即终止执行，分配 CPU 资源给其他进程。</li><li>若还有子孙进程，通常需要将所有子孙进程终止。</li><li>将进程全部资源归还给<strong>父进程或操作系统</strong>。</li><li>将 PCB 从<strong>队列或链表</strong>中删除。</li></ol></li></ul></li><li><p><strong>进程的阻塞和唤醒（14 19 18 22 23）</strong></p><ul><li>进程由于期待事件未发生或无新任务可做，调用阻塞原语，将自身从运行态变为阻塞态。这是<strong>主动行为</strong>，也只有获得了 CPU 的运行态程序可以进入阻塞态。</li><li><strong>阻塞原语的执行过程：</strong><ol><li>找到进程标识号（PID）对应的 PCB</li><li>若为运行态，则保护现场，状态转为阻塞态，停止运行。</li><li>将 PCB 插入相应事件的等待队列，将 CPU 资源调度给其他就绪进程。</li></ol></li><li><strong>进程唤醒的事件和时机</strong><ul><li>期待的事件（IO 完成或期待数据到达等）出现时，有关进程调用唤醒原语。<ul><li><strong>唤醒原语的执行过程：</strong><ol><li>在该事件的等待队列中找到相应进程的 PCB</li><li>将其移出等待队列，状态改为就绪态。</li><li>PCB 插入就绪队列，等待调度</li></ol></li></ul></li><li>阻塞原语和唤醒原语必须成对使用。</li></ul></li></ul></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>PV 操作是低级通信方式。</p><ul><li>高级通信方式是以较高速率传输大量数据的通信方式。主要有下面三类。<ul><li><strong>共享存储</strong><ul><li>通信的进程之间存在一块可以直接访问的共享空间。</li><li>对共享空间的读写操作需要利用同步互斥工具（如 PV）进行控制。</li><li>进程空间一般是独立的，所以需要特殊系统调用实现共享。</li></ul></li><li><strong>消息传递</strong><ul><li>数据交换以格式化的信息为单位。</li><li>利用操作系统提供的发送消息和接收消息的原语进行数据交换。</li><li>对用户透明</li><li>微内核常用，微内核和服务器间通信</li></ul></li><li><strong>管道通信（2014）</strong><ul><li>管道是一个特殊的共享<strong>文件</strong>，数据在管道中<strong>先进先出</strong>。</li><li>管道通信允许两个进程按<strong>生产者-消费者</strong>方式进行通信，只要管道不满，写进程就能向管道写入数据；只要管道非空，读进程就能从管道读出数据。</li><li>管道应提供三方面协调能力：<ul><li><strong>互斥，<strong>同时只能有一个进程对管道读&#x2F;写。</strong>（14 一个管道只能有一个读进程或一个写进程对其操作 ✗ 可以有，但应避免。）</strong></li><li>**同步，**向管道写入一定量数据后，写进程阻塞，读进程读数据后唤醒。读进程读空管道后，读进程阻塞，写进程写入管道后唤醒。</li><li><strong>确定对方的存在。</strong></li></ul></li><li>Linux 中的常用通信机制。</li><li>管道也是一种文件。与普通文件通信相比，使用管道能够<strong>限制管道大小</strong>。Linux 中固定为 4KB，不会不加检验地增长。</li><li>管道只能由创建它的进程访问。父进程创建一个管道后，子进程会继承父进程的打开文件，同时也继承管道文件，可以用它与父进程通信。</li><li>从管道<strong>读数据是一次性操作</strong>。数据被读取后即被释放。</li><li>普通管道<strong>只允许单向通信</strong>，双向通信需要两个管道。</li></ul></li></ul></li></ul><h3 id="线程和多线程模型"><a href="#线程和多线程模型" class="headerlink" title="线程和多线程模型"></a>线程和多线程模型</h3><p>引入线程的目的：减小程序在并发执行时的时空开销，提高 OS 并发性能。</p><p>线程是一个基本的 CPU 执行单元，也是程序执行流的最小单元。</p><p>由<strong>线程 ID、程序计数器、寄存器集合和堆栈</strong>组成。</p><p>线程是<strong>进程中的一个实体</strong>，是被系统独立调度和分派的基本单位。</p><p>线程自己不拥有系统资源，只有一点在运行中必不可少的资源，但它可与<strong>同属于一个进程的其他线程</strong>共享所拥有的全部资源。</p><p>线程可以<strong>创建、撤销其他线程</strong>，同一进程中的多个线程可以并发。</p><p>线程间相互制约，导致运行中会出现间断性。所以线程有<strong>就绪、阻塞、运行</strong>三种状态。</p><p>引入线程后，进程只作为除了 CPU 以外的系统资源的分配单元，线程作为 CPU 的分配单元。</p><p>线程的切换若在进程内部，只需很小的时空开销。</p><ul><li><p><strong>线程和进程的比较（12）</strong></p><ul><li>**调度。**引入线程的 OS 中，线程是独立调度的基本单位，<strong>线程切换的代价远低于进程</strong>。传统 OS 中调度在进程之间，开销大。</li><li>**并发性。**引入线程的 OS 中，进程可并发，同一或不同进程的线程也可并发，提高了资源利用率和系统吞吐量。</li><li>**拥有的资源。<strong>进程是拥有系统资源的基本单位，线程不拥有系统资源，只有一点在运行中必不可少的资源</strong>。**但线程可以访问其隶属进程的系统资源。（同一进程的所有线程有相同的地址空间）</li><li>**独立性。**进程有独立地址空间和资源，除共享部分，不允许其他进程访问。某个进程中的线程对其他进程不可见，这些线程共享进程的地址空间和资源。</li><li>**系统开销。**创建或撤销进程的时候，系统要分配、回收 PCB 等资源，切换进程时也涉及上下文切换。线程切换时只要保存少量寄存器内容，开销小。线程间的同步和通信实现也更简单。</li><li>**支持多处理器系统。**多线程进程可以将多个线程分配到多个 CPU 上。</li><li>线程的提出提高系统并发性的理解：线程切换时，可能切换进程，也可能不切换，平均看来切换所需开销就变小。</li></ul></li><li><p><strong>线程的属性（11 24）</strong></p><ul><li>线程是一个轻型实体，不拥有系统资源，但每个线程都应有一个唯一标识符、一个线程控制块，线程控制块记录线程执行的寄存器和栈等现场状态。</li><li>不同线程可以执行相同的程序。即同一服务程序被不同用户调用时，OS 将为它们创建不同的线程。</li><li>同一进程中各个线程共享该进程的资源。</li><li>线程是 CPU 的独立调度单位，可以并发。</li><li>线程有其生命周期，有阻塞态 就绪态 运行态。<ul><li>运行态：线程获得 CPU，正在运行。</li><li>就绪态：已具备各种执行条件，只需要获得 CPU 就可以运行。</li><li>阻塞态：执行中因某时间受阻而暂停。</li><li>三种状态的转换与进程一致。</li></ul></li></ul></li><li><p><strong>线程的组织和控制（19 24）</strong></p><ul><li>线程控制块 TCB 包括：<ul><li>线程标识符</li><li>一组寄存器，包括 PC 状态寄存器和通用寄存器</li><li>线程运行状态</li><li>优先级</li><li>线程专有存储区，用于线程切换时保护现场</li><li>堆栈指针，用于过程调用时保存局部变量以及返回地址</li></ul></li><li>一个线程可以读写或清除另一个线程的堆栈。<strong>（11 进程 P 创建的若干线程不能共享进程 P 中某个线程的栈指针 这一部分是独享的）</strong></li><li>OS 中存在用于创建 终止线程的函数或系统调用。</li><li>用户程序启动时，通常仅有一个初始化线程正在执行，主要功能是创建新的线程。</li><li>有的线程被建立后，会一直运行而不被终止。</li><li>线程被终止后并不立即释放所拥有的资源。只有当进程中的其他线程执行分离函数之后，被终止的线程才与资源分离，资源才能被其他线程利用。</li><li>被终止但未被释放资源的线程可以被其他线程调用，使得被终止线程恢复运行。</li></ul></li><li><p><strong>线程的实现方式（19）</strong></p><ul><li>线程的实现分为两类<ul><li><strong>用户级线程（User-Level Thread ULT）</strong><ul><li>“用户视角能看到的线程”</li><li>线程创建撤销切换等所有工作都在<strong>用户态</strong>完成，内核不知道线程的存在。</li><li>应用程序从单线程开始，在该线程中开始运行，运行时可以调用线程库中的派生例程创建一个在相同进程中运行的新线程。<ul><li>线程库是为程序员提供的创建和管理线程的 API。比如 Pthreads、Windows API、Java</li></ul></li><li>设置了用户级线程的系统，调度仍然以进程为单位，各进程轮换时间片。若 A 进程线程少，B 进程线程多，A 进程中线程的执行时间则更长，对线程而言不公平。</li><li>优点<ul><li>线程切换<strong>不需要切换到内核态</strong>，节约模式切换的开销</li><li>调度算法可以是进程专用的，不同的进程可以根据需要选择自己的线程调度算法</li><li>用户级线程的实现是用户程序的一部分，与 OS 无关</li></ul></li><li>缺点<ul><li><strong>系统调用的阻塞问题</strong>。线程执行一个系统调用时，该线程以及进城内所有线程都被阻塞。</li><li><strong>不能发挥多 CPU 优势</strong>。进程中同时只有一个线程运行。</li></ul></li></ul></li><li><strong>内核级线程（Kernel-Level Thread KLT），<strong>又称</strong>内核支持的线程</strong><ul><li>线程管理的所有工作在<strong>内核态</strong>进行。</li><li>OS 给每个内核级线程设置一个 TCB。</li><li>优点<ul><li><strong>发挥多 CPU 优势</strong>，同一进程的多线程能并发。</li><li>进程中的一个线程被阻塞时，进程的其他线程可以占用 CPU，也可以运行其他进程中的线程。</li><li>内核支持线程有很小的数据结构和堆栈，<strong>切换快，开销小</strong>。</li><li>内核本身可以采用多线程技术，提高系统执行速度和效率。</li></ul></li><li>缺点<ul><li>同一进程中的线程切换需要从用户态到内核态，开销较大。这是因为用户进程的线程在用户态运行，但调度和管理是在内核态。</li></ul></li></ul></li><li><strong>组合方式</strong><ul><li>内核支持多个内核级线程的管理，也允许用户管理用户级线程。综合上面优点，克服上面缺点。</li><li>用户级线程和内核级线程的连接方式<ul><li>多对一模型<ul><li>多个用户级线程映射到一个内核级线程。</li><li>线程管理在用户态 效率高</li><li>一个线程被阻塞会导致整个进程的阻塞。多个线程不能分到多个 CPU 上。</li></ul></li><li>一对一模型<ul><li>每个用户级线程映射到一个内核级线程。</li><li>线程被阻塞后，允许调度另一个线程，并发能力较强</li><li>每创建一个用户线程，就需要创建一个内核线程，开销大。</li></ul></li><li>多对多模型<ul><li>n 个用户级线程映射到 m 个内核级模型，n &gt;&#x3D; m</li><li>综合上面优点，克服上面缺点。</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h2><p>调度的层次（没考过，略）</p><h3 id="调度的实现"><a href="#调度的实现" class="headerlink" title="调度的实现"></a>调度的实现</h3><ul><li><p>调度程序</p><ul><li>排队器<ul><li>按策略将就绪进程排队</li></ul></li><li>分派器<ul><li>将 CPU 分配给新进程</li></ul></li><li>上下文切换器<ul><li>两对上下文切换：<ul><li>当前进程上下文存到其 PCB 里，装入分派程序的上下文，使分派程序运行</li><li>移出分派程序上下文，将新选进程的 CPU 现场信息装入各寄存器</li></ul></li></ul></li></ul></li><li><p><strong>调度的时机、切换与过程</strong></p><ul><li><strong>现代 OS 中，应该进行进程调度与切换的情况如下：（12 21）</strong><ul><li>创建新进程后，由于父进程和子进程都在就绪态，因此需要决定运行父进程还是子进程。此时由调度程序决定。</li><li>进程正常结束或异常终止后，必须从就绪队列中选择进程运行。若没有就绪进程则运行闲逛进程。<ul><li>闲逛进程优先级最低，不需要 CPU 以外的资源，不会被阻塞</li></ul></li><li>进程因 I&#x2F;O 请求 PV 操作等被阻塞时，需要调度其他进程。</li><li>IO 设备完成后，发出 IO 中断，原先等待 IO 的进程变为就绪态，此时需要决定是让新的就绪进程运行还是中断发生时的进程继续运行。</li><li>有些系统中，有更高优先级的进程进入就绪队列需要处理时，也被强行剥夺 CPU。</li></ul></li><li>进程切换在调度完成后立刻发生。要求保存原进程当前断点的现场，恢复被调度进程的现场。</li><li><strong>不能进行进程的调度与切换的情况：</strong><ul><li>处理中断的过程中。</li><li>需要完全屏蔽中断的原子操作过程中。</li></ul></li></ul></li><li><p><strong>进程调度的方式</strong></p><ul><li>非抢占调度，当有优先级更高的进程进入就绪队列，仍然让进程继续执行直到正常结束、异常终止或者进入阻塞态。</li><li>抢占调度，更高优先级的进程会抢占 CPU</li></ul></li><li><p><strong>两种线程的调度</strong></p><ul><li>用户级线程调度：进程中的调度程序决定哪个线程运行，只需要少量机器指令</li><li>内核级线程调度：内核选择一个特定线程运行，通常不考虑属于哪个进程。给选中线程赋予一个时间片。需要完整的上下文切换、修改内存影像、使高速缓存失效，延迟高。</li></ul></li></ul><h3 id="调度的相关计算（12-16-18-19-23-24）"><a href="#调度的相关计算（12-16-18-19-23-24）" class="headerlink" title="调度的相关计算（12 16 18 19 23 24）"></a>调度的相关计算（12 16 18 19 23 24）</h3><p>**CPU 利用率：**CPU 有效工作时间 ÷（CPU 有效工作时间 +CPU 空闲时间）</p><p>计算作业完成时间的时候，要注意 CPU 与设备、设备之间可以<strong>并行</strong>。</p><p>**系统吞吐量：**单位时间内 CPU 完成作业的数量。</p><p><strong>周转时间：<strong>作业完成时间-作业提交时间，是作业等待、在就绪队列中排队、在 CPU 上运行、IO 操作花费时间总和。</strong>（不是运行时间）</strong></p><p><strong>平均周转时间</strong>是多个作业周转时间直接取平均。</p><p><strong>带权周转时间</strong>：作业周转时间 ÷ 作业实际运行时间（？这不是个比值？为啥叫时间？）<strong>（注意分子分母）</strong></p><p><strong>平均带权周转时间</strong>是多个作业带权周转时间直接取平均。</p><p>**等待时间：**是指进程处于等待 CPU 的时间之和。</p><p>**响应时间：**指从用户提交请求到系统首次响应的时间。</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>对于通常进程而言，其创建、撤销、以及要求由系统设备完成的 IO 操作都是<strong>利用系统调用进入内核</strong>，内核中的处理程序完成的。进程切换也是在<strong>内核</strong>的支持下实现的。<strong>（23）</strong></p><p>调度和切换的区别：调度是指决定资源分配给谁的行为，是决策；切换是实际分配过程，是执行。先有资源调度，后有进程切换。</p><ul><li><p><strong>切换进程的操作（上下文切换）（24）</strong></p><ul><li>挂起一个进程，将 CPU 上下文保存到 PCB，包括 PC 和其他寄存器。</li><li>将进程 PCB 移入相应队列，如就绪、阻塞队列</li><li>选择另一个进程执行，<strong>更新其 PCB</strong></li><li>恢复新进程的 CPU 上下文</li><li>跳转到新进程 PCB 中的 <strong>PC 指向的位置</strong>执行。</li></ul></li><li><p>上下文切换的消耗</p><ul><li>计算密集型，需要大量 CPU 时间。但有的 CPU 提供多个寄存器组，此时只需改变寄存器组指针。</li></ul></li><li><p>上下文切换和模式切换</p><ul><li>模式切换时，CPU 逻辑上可能还在执行同一进程。进程运行可能从用户态进入内核态再返回。</li><li>上下文切换<strong>只发生在内核态。</strong></li></ul></li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p>各种算法的特点和对比（<strong>09 11 14</strong>）</p><ul><li><p><strong>先来先服务（FCFS）调度算法（17）</strong></p><ul><li>进程调度中，FCFS 算法每次从就绪队列中选择最先进入该队列的进程，将 CPU 分配给它，直到运行结束或者被阻塞。</li><li>作业调度同理。</li><li>FCFS 属于不可剥夺算法。</li><li>特点：算法简单；效率低；对长作业有利，对短作业不利（相对于 SJF 和高响应比）；有利于 CPU 繁忙型作业，不利于 IO 繁忙型作业。</li></ul></li><li><p><strong>短作业优先（SJF shortest job first）（17）</strong></p><ul><li>短作业优先（SJF）调度：从后备队列中选择<strong>一个或者几个</strong>估计运行时间最短的作业，调入内存运行</li><li>短进程优先（SPF）调度：从就绪队列中选<strong>一个</strong>估计运行时间最短的进程分配 CPU。</li><li>算法对长作业不利，有可能导致长作业长期不被调度，产生饥饿现象。<ul><li>饥饿是调度策略问题，死锁是系统环形等待，注意区分<strong>饥饿和死锁</strong>。（16）</li></ul></li><li>SPF 算法默认非抢占式，但也可以是抢占式的。规则是新进程的执行时间比当前进程<strong>剩余</strong>时间小，则抢占。</li></ul></li><li><p><strong>高响应比优先调度算法</strong></p><ul><li>主要用于作业调度。每次调度时先计算作业队列中每个的响应比，选最高的投入运行。</li><li><strong>响应比 &#x3D; (等待时间 + 要求服务时间) &#x2F; 要求服务时间</strong></li><li>等待时间相同时，要求服务时间越短，响应比越高，有利于短作业</li><li>要求服务时间相同时，等待时间越长，响应比越高，可以克服饥饿现象。</li></ul></li><li><p><strong>优先级调度算法（10 13 16 18 22 23）</strong></p><ul><li>可以用于作业调度和进程调度。分为抢占式和非抢占式。优先级可变或不可变。</li><li>优先级设置一般<ul><li>系统进程 &gt; 用户进程</li><li>交互型进程 ＞ 非交互型进程（或 前台 ＞ 后台）</li><li>I&#x2F;O 型进程 &gt; 计算型进程（13）<ul><li>I&#x2F;O 进程指频繁使用 I&#x2F;O 设备的进程，计算型进程指频繁使用 CPU 的进程</li><li>I&#x2F;O 设备处理速度慢，要让其尽早开始工作。</li></ul></li></ul></li></ul></li><li><p><strong>时间片轮转（RR）调度算法（17 21 24）</strong></p><ul><li>主要适用于分时系统。系统将所有的就绪进程按 FCFS 策略排成就绪队列，系统每隔一段时间产生一次时钟中断，激活调度程序调度，将 CPU 分配给队首进程，执行一个时间片。</li><li><strong>时间片执行完后，产生一个时钟中断，激活调度程序。若进程没有运行完，则释放 CPU 给新的队首进程，自己到队尾重新排队。</strong></li><li><strong>若时间片没有用完而进程已经运行完，调度程序立即被激活。</strong></li><li>对时间片大小的分析：<ul><li>若时间片够大，所有进程都能在一个时间片内执行完，则退化为 FCFS 算法</li><li>若时间片过小，则 CPU 频繁切换，开销很大。</li><li>时间片的大小应该由系统的相应事件、就绪队列的进程数目和系统的处理能力决定。</li></ul></li></ul></li><li><p><strong>多级队列调度算法</strong></p><ul><li>设置多个就绪队列，将不同类型或性质的进程分到各个就绪队列，每个队列实施不同的调度算法。</li><li>同一队列中的进程可以设置优先级，不同队列也可以设置优先级。</li><li>多 CPU 中，可以为每个 CPU 设置一个单独的就绪队列，每个 CPU 实施不同调度策略，这样就可以根据用户需求将多个线程分配到一个或多个 CPU 上运行。</li></ul></li><li><p><strong>多级反馈队列调度算法（综合各算法优点）（19 20）</strong></p><ul><li>动态调整进程优先级和时间片大小，兼顾多方面系统目标</li><li>比如为提高系统吞吐量、缩短平均周转时间照顾短进程</li><li>比如为获得较好的 I&#x2F;O 设备利用率、缩短响应时间照顾 I&#x2F;O 进程</li><li>不必事先估计进程执行时间</li><li><strong>实现思想：</strong><ul><li>设置多个就绪队列，为每个队列赋予不同优先级。</li><li>赋予各个队列的进程运行时间片的大小不同。优先级越高的队列中，时间片越小。</li><li>每个队列采用 FCFS 算法。首先放入第 1 级队列的末尾，等待调度。轮到其执行时，若未完成，则进入第 2 级队列末尾，以此类推。</li><li>仅第 1 ~ i - 1 级队列为空时，调度第 i 级队列中进程运行。</li><li>如果 CPU 执行第 i 级队列中进程时，新进程进入优先级更高的队列，此时立即将正在运行的进程放入第 i 级队列末尾，执行新的进程。</li></ul></li><li><strong>优势：</strong><ul><li>对于终端型作业用户，短作业优先（？）<ul><li>GPT：终端型作业是交互式的，用户可以直接与系统进行交互。用户在终端（如命令行界面）输入命令，系统立即处理并返回结果。</li></ul></li><li>对于短批处理作业用户，周转时间较短</li><li>对于长批处理作业用户，经过前面几个队列得到部分执行，不会长期得不到处理。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
